#!/usr/bin/env node

"use strict";

const os = require('os');
const path = require('path');
const _ = require("../lib/_.js");

const tmux = require("../lib/tmux.js");

const _config_path = path.join(os.homedir(), ".tux.js");

function get_config(){

   let config;

   try{ config = require(_config_path); }
   catch(e){
      throw _.error("config_error", "missing config file ~/.tux.js or there was a problem with it: ", e.toString());
   }

   config = _.merge({}, config);

   const meta = config.meta;

   delete config.meta;

   _.each(config, function(session, key){
      if(_.is_ary(session)){
         session = _.merge({ tabs: session });
      }else{
         session = _.merge(meta.default, session, {
            name: key,
            title: session.title || key,
            dir: _.path.expand_tilde(session.dir || _.fatal("missing dir for: ", key)),
         });
      }
      if(session.windows){
         session.windows = session.windows.map(function(value){
            if(typeof value === "string"){
               return({ run: value, layout: true });
            }else if(Array.isArray(value)){
               return({ run: value[0], layout: false });
            }else{
               return(value);
            }
         });
      }
      config[key] = session;
   });

   return(config);
}

const _cmds = {};

const help = function(exit){

   const str = [
      `usage: tux [ ${ _.keys(_cmds).join(", ") }, <session_name>]`
   ];

   _.stdout(...str);

   if(_.def(exit)){ _.exit(exit); }
}

_cmds.help = help;

_cmds.config = function(){
   _.stdout(JSON.stringify(get_config(), null, 3));
};

_cmds.fzf = function(){

   const { spawn } = require("child_process");

   const fzf = spawn("fzf", [], { stdio: ["pipe", "pipe", process.stderr] });

   let selection = '';

   fzf.stdout.on("data", function(data){ selection += data.toString(); });

   fzf.on("close", function(){
      selection = selection.trim();
      if(selection){
         selection = selection.split(" ")[0].trim();
         _.debug("selection: ", selection);
         _cmds.run([ selection ]);
      }
   });

   fzf.stdin.write(_ls());
   fzf.stdin.end();
};

_cmds.layout = function([ name ]){
   tmux.layout({ name });
};

_cmds.at = function(){
   console.dir(tmux);
   const { stdout } = tmux.run("list-sessions");
   _.stdout.write(stdout);
};

_cmds.edit = function(){
   let editor = process.env.EDITOR;
   if(!editor){
      editor = "vi";
      _.stderr("WARNING: $EDITOR is not set. using vi.");
   }
   _.shell(editor + " " + _config_path);
};

_cmds.add = function([ dir ]){
   if(!dir){ dir = "."; }
   dir = path.resolve(dir);
   dir = _.path.shorten_tilde(dir);

   const fs = require('fs');
   const section = [
      `config.NAME_ME = {`,
      `   dir: "${dir}",`,
      `   title: "TITLE ME",`,
      `   // remove "windows" section to get the default windows.`,
      `   windows: ["CMD_ONE", "CMD_TWO"]`,
      `};`
   ];
   fs.appendFileSync(_config_path, "\n" + section.join("\n"));
   _cmds.edit();
};

function _ls(){

   const config = get_config();
   const list = [];

   let max_key_len = 0;

   _.each(config, function(session, key){
      max_key_len = Math.max(key.length, max_key_len);
   });

   _.each(config, function(session, key){
      if(session.tabs){
         list.push(key.padEnd(max_key_len, " ") + ":  [ " + session.tabs.join(", ") + " ]");
      }else{
         list.push(key.padEnd(max_key_len, " ") + ":  " + _.path.shorten_tilde(session.dir || ""));
      }
   });

   return(list.join("\n"));
}

_cmds.compinit = function(){

   const config = get_config();

   const list = [
      'fzf:pick a session to run with fzf',
      'add:add a new item to tux',
      'edit:edit tmux config',
      'ls:list possible sessions',
      'run:run a session',
      'config:print the expanded tmux config',
      'at:list attached sessions',
      'help:print help',
   ];

   // _.each(config, function(session, key){
   //    if(session.tabs){
   //       list.push(key + ":[ " + session.tabs.join(", ") + " ]");
   //    }else{
   //       list.push(key + ":" + _.path.shorten_tilde(session.dir || ""));
   //    }
   // });

   _.stdout(list.join("\n"));
};

_cmds.ls = function(){ _.stdout(_ls()); };

_cmds.run = async function([ session_name ]){

   const config = get_config();

   if(!session_name){
      _.stderr("abort: You must enter a session name.");
      return help(1);
   }

   let session = config[session_name];

   if(!session){
      _.stderr(`error: config file section not found: "${ session_name }". you need a config file section for this to work.`);
      _.exit(1);
   }

   if(session.tabs){
      for(let i = 0; i < session.tabs.length; i++){
         const tux_session_name = session.tabs[i];
         _.spawn("tab -d '' tux " + tux_session_name);
         await _.timeout(2_000);
      }
   }else{

      if(tmux.session.exists(session)){
         _.debug("session exists: ", session.name);
         _.debug("attaching.");
         return tmux.session.attach(session);
      }

      await tmux.session.create({ session });

      tmux.session.attach(session);
   }
};

;(function main(){

   const args = process.argv.slice(2);

   const cmd = args.shift();

   if(_.undef(cmd)){ return _cmds.fzf(); }

   if(_cmds[cmd]){ return _cmds[cmd](args); }
   else{ _cmds.run([ cmd ]); }

})();
